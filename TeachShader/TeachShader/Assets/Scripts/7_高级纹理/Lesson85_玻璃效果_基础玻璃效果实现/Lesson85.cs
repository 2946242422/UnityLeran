using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Lesson85 : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        #region 知识回顾 
        //1.玻璃效果基本原理
        //  在渲染玻璃效果之前，先捕获当前屏幕内容并保存到一张渲染纹理当中，
        //  在之后的Shader处理中利用该渲染纹理进行采样，参与最终的颜色计算，实现
        //  各种玻璃效果。
        //2.玻璃效果实现使用的新知识点
        //  捕获屏幕内容的GrabPass；
        //  裁剪坐标转屏幕坐标的ComputeGrabScreenPos方法
        //  捕获纹理进行采样时，进行一些偏移计算，模拟折射效果
        //3.渲染标签中的 渲染队列
        //  Tags{ "Queue" = "标签值" }
        //  常用Unity预先定义好的渲染队列标签值：

        //  3-1.Background(背景)(队列号:1000)
        //  最早被渲染的物体的队列，一般用来渲染天空盒或者背景
        //  Tags{ "Queue" = "Background" }

        //  3-2.Geometry(几何)(队列号:2000)
        //  不透明的几何体通常使用该队列，当没有声明渲染队列时，Unity会默认使用这个队列
        //  Tags{ "Queue" = "Geometry" }

        //  3-3.AlphaTest(透明测试)(队列号:2450)
        //  有透明通道的，需要进行Alpha测试的几何体会使用该队列
        //  当所有Geometry队列实体绘制完后再绘制AlphaTest队列，效率更高
        //  Tags{ "Queue" = "AlphaTest" }

        //  3-4.Transparent(透明的)(队列号:3000)
        //  该队列中几何体按照由远到近的顺序进行绘制，半透明物体的渲染队列，所有进行透明混合的几何体都应该使用该队列
        //  比如：玻璃材质，粒子特效等
        //  Tags{ "Queue" = "Transparent" }

        //  3-5.Overlay(覆盖)(队列号:4000)
        //  用是放在最后渲染的队列，于叠加渲染的效果，比如镜头光晕等
        //  Tags{ "Queue" = "Overlay" }

        //  3-6.自定义队列
        //  基于Unity预先定义好的这些渲染队列标签来进行加减运算来定义自己的渲染队列
        //  比如：
        //  Tags{ "Queue" = "Geometry+1" }    代表的队列号就是 2001
        //  Tags{ "Queue" = "Transparent-1" } 代表的队列号就是 2999
        //  自定义队列在一些特殊情况下，特别有用
        //  比如 一些水的渲染 想要在不透明物体之后，半透明物体之前进行渲染，就可以自定义
        #endregion

        #region 知识点一 如何让玻璃效果对象滞后渲染 
        //我们上节课知道
        //在实现玻璃效果之前，需要先捕获当前屏幕内容并保存到一张渲染纹理当中
        //那么要保证玻璃效果对象后面的内容正确渲染，我们必须保证玻璃对象能够滞后渲染

        //想要让一个对象滞后渲染，那么通过我们学习过的知识，自然的联想到了
        //渲染标签Tags中的 渲染队列Queue

        //因此对于玻璃效果对象，虽然它本质上是一个不透明物体
        //但是我们完全可以将它的渲染队列设置为 Transparent(透明的) 
        //保证它晚于 背景队列、几何队列、透明测试队列 之后再进行渲染
        //这时我们捕获的屏幕内容，将包含这些更早渲染的内容信息
        //便可以利用GrabPass捕获到相对正确的内容了
        #endregion

        #region 知识点二 基础玻璃效果实现
        //1.新建一个Shader，复制反射基础实现Lesson75_ReflectBase中的代码
        //2.修改相关代码
        //  2-1:修改属性代码（同时修改CG中的属性映射）
        //      加入主纹理属性（用于处理物体本身颜色）
        //      加入立方体纹理属性（用于处理反射）
        //      将反射率改为折射程度（用于控制折射程度 0表示完全不折射-相当于完全反射，1表示完全折射-相当于完全透明）
        //  2-2:修改渲染队列为Transparent，
        //      但是RenderType渲染类型不修改，因为它本质上还是一个不透明物体
        //      以后使用着色器替换功能时，可以在被正常渲染
        //  2-3:加入GrabPass，抓取屏幕图像存储渲染纹理
        //  2-4:修改v2f结构体
        //      加入相对屏幕坐标float4类型成员
        //      加入uv，用于采样物体颜色纹理
        //  2-5:修改顶点着色器
        //      使用ComputeGrabScreenPos方法，计算结构体中相对屏幕坐标
        //      计算纹理的缩放偏移
        //  2-6:修改片元着色器
        //      用uv采样主纹理颜色
        //      将屏幕坐标转为裁剪坐标0~1范围内，对捕获纹理进行采样
        //      用反射在立方体纹理中进行采样，用结果乘以主纹理颜色，进行颜色叠加
        //      用折射程度参与最终的颜色计算，折射程度值的变化决定了最终表现效果在 完全反射~完全折射 之间变化
        #endregion

        #region 知识点三 自定义折射效果
        //目前我们利用屏幕坐标在抓取纹理中采样并没有处理偏移
        //因此呈现出来的效果像是在透明和半透明之前切换
        //我们可以自定义一些简单的偏移计算规则
        //让最终的采样位置发生偏移，模拟折射效果
        #endregion
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
