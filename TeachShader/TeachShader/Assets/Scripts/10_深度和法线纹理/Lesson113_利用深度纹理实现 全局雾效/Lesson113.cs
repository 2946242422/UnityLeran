using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Lesson113 : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        #region 知识回顾 基本原理
        //全局雾效的三种计算方式
        //Linear（线性）：f = (end - |d|) / (end – start) 
        //Exponential（指数）： f = 1 –  𝒆^−𝒅𝒆𝒏𝒔𝒊𝒕𝒚∗|𝒅|
        //Exponential Squared（指数的平方）： f = 1 –  𝒆^−(𝒅𝒆𝒏𝒔𝒊𝒕𝒚−|𝒅|)

        //最终的颜色 = （1-f）* 物体的颜色+ f * 雾的颜色

        //实现全局雾效的基本原理
        //求出像素的世界坐标，从而得到离摄像机的距离，从而参与到雾效公式的计算中
        //像素的世界坐标 = 摄像机位置 + 观察空间线性深度值 * 摄像机指向像素世界坐标的方向向
        //关键思路：
        //1.屏幕后处理中处理的内容是一张抓取的屏幕图像，相当于是一个面片，它具有4个顶点（四个角）
        //2.通过C#代码计算四个顶点在世界坐标系下的射线方向后传递给顶点着色器
        //  当数据传递到片元着色器要处理每个像素时，像素对应的射线方向是基于4个顶点的射线插值计算而来(无需我们自己计算)
        //3. 利用 像素世界坐标= 摄像机位置+ 深度值* 世界空间下射线方向得到对应像素在世界空间下位置
        //4.利用得到的世界空间下位置利用雾的公式计算出对应雾效颜
        #endregion

        #region 知识点一 实现 利用深度纹理实现全局雾效屏幕后期处理效果 对应 C#
        //1.新建C#代码，取名FogWithDepthTexture
        //2.继承PostEffectBase，重写OnRenderImage
        //3.Start中开启深度纹理
        //4.声明雾相关属性
        //  颜色、浓度、开始距离、最浓距离
        //5.根据上节课的原理，计算四个顶点的四个射线向量
        //6.通过4x4的矩阵装载各摄像向量，传递给材质
        //  注意：为了方便之后考虑uv翻转问题，我们按左下、右下、右上、左上的逆时针顺序存储
        //7.将定义好的颜色、浓度、开始距离、最浓距离传递给材质球
        #endregion

        #region 知识点二 实现 利用深度纹理实现全局雾效屏幕后期处理效果 对应 Shader
        //1.新建Shader代码，取名和C#相同，删除无用代码
        //2.声明属性，映射属性，注意属性和C#中命名相同
        //  还有深度纹理、矩阵、纹素属性
        //3.屏幕后处理标配
        //  ZTest Always
        //  Cull Off
        //  ZWrite Off
        //4.v2f结构体
        //  考虑翻转的深度纹理half2 uv_depth:TEXCOORD1
        //  射线向量 loat4 ray:TEXCOORD2
        //5.顶点着色器(图片有四个顶点，会进入四次，我们需要判断每一个顶点使用哪一个射线向量）
        //  坐标转换、uv赋值（考虑深度纹理翻转）
        //  根据uv坐标判断顶点位置，决定赋值哪一个向量
        //  同样需要考虑翻转
        //6.片元着色器
        //  深度纹理采样，转换到观察空间下离摄像机的实际距离
        //  利用 摄像机位置 + 深度值*射线向量 得到世界空间坐标
        //  利用雾公式 算出混合因子 我们这里不使用传统雾公式
        //  我们实现一种特殊的基于高度的线性雾效 并且把浓度也用上
        //  利用混合因子 进行颜色混合
        //7.FallBack Off
        #endregion
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
